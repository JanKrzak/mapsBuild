!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("@angular/forms"),require("@agm/core"),require("@angular/common"),require("@angular/material")):"function"==typeof define&&define.amd?define(["exports","@angular/core","@angular/forms","@agm/core","@angular/common","@angular/material"],t):t(e.angularMaterialExtensionsGoogleMapsAutocomplete={},e.ng.core,e.ng.forms,e.agmCore,e.ng.common,e.ng.material)}(this,function(e,t,o,n,r,a){"use strict";var s=function(){function e(){}return e.prototype.validate=function(){var e=this;return function(t){return e.address?null:{validateAddress:{valid:!1}}}},e.prototype.subscribe=function(e){var t=this;this.subscription=e.subscribe(function(e){t.address=e})},e.prototype.unsubscribe=function(){this.subscription.unsubscribe()},Object.defineProperty(e.prototype,"address",{get:function(){return this._address},set:function(e){this._address=e},enumerable:!0,configurable:!0}),e.decorators=[{type:t.Directive,args:[{selector:"[mat-addressInput-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]",providers:[{provide:o.NG_VALIDATORS,useExisting:t.forwardRef(function(){return e}),multi:!0}]}]}],e.ctorParameters=function(){return[]},e}(),i={STANDARD:"standard",FILL:"fill",OUTLINE:"outline",LEGACY:"legacy"},l=function(){function e(e,n){this._mapsAPILoader=e,this._ngZone=n,this.addressLabelText="Address",this.placeholderText="Please enter the addressInput",this.requiredErrorText="The addressInput is required",this.invalidErrorText="The addressInput is not valid",this.appearance=i.STANDARD,this.autoCompleteOptions={},this.onChange=new t.EventEmitter,this.onAutocompleteSelected=new t.EventEmitter,this.onLocationSelected=new t.EventEmitter,this.onNewPlaceResult=new t.EventEmitter,this.addressValidator=new s,this.addressSearchControl=new o.FormControl({value:null},o.Validators.compose([o.Validators.required,this.addressValidator.validate()]))}return e.prototype.ngOnInit=function(){this.addressValidator.subscribe(this.onNewPlaceResult);var e={componentRestrictions:{country:this.country},placeIdOnly:this.placeIdOnly,strictBounds:this.strictBounds,types:this.types,type:this.type};this.autoCompleteOptions=Object.assign(this.autoCompleteOptions,e),this.initGoogleMapsAutocomplete()},e.prototype.initGoogleMapsAutocomplete=function(){var e=this;this._mapsAPILoader.load().then(function(){var t=new google.maps.places.Autocomplete(e.searchElementRef.nativeElement,e.autoCompleteOptions);t.addListener("place_changed",function(){e._ngZone.run(function(){var o=t.getPlace();o.place_id&&void 0!==o.geometry&&null!==o.geometry&&(e.address=o.formatted_address,e.onAutocompleteSelected.emit(o),e.onLocationSelected.emit({latitude:o.geometry.location.lat(),longitude:o.geometry.location.lng()}))})})}).catch(function(e){return console.log(e)})},e.prototype.onQuery=function(e){this.onChange.emit(this.address)},e.prototype.resetAddress=function(){this.address=null,this.addressSearchControl.updateValueAndValidity()},e.decorators=[{type:t.Component,args:[{selector:"mat-google-maps-autocomplete",exportAs:"matGoogleMapsAutocomplete",template:'\n    <mat-form-field class="full-width" [appearance]="appearance">\n      <mat-label>{{addressLabelText}}</mat-label>\n      <input matInput\n             [(ngModel)]="addressInput"\n             (change)="onQuery($event)"\n             placeholder="{{placeholderText}}"\n             class="form-control"\n             #search\n             MatValidateAddress\n             required>\n      <mat-error *ngIf="addressSearchControl.hasError(\'required\')">\n        {{requiredErrorText}}\n      </mat-error>\n      <mat-error *ngIf="addressSearchControl.hasError(\'validateAddress\')">\n        {{invalidErrorText}}\n      </mat-error>\n    </mat-form-field>\n  ',styles:["\n    .full-width{width:100%}\n  "]}]}],e.ctorParameters=function(){return[{type:n.MapsAPILoader},{type:t.NgZone}]},e.propDecorators={searchElementRef:[{type:t.ViewChild,args:["search"]}],addressLabelText:[{type:t.Input}],placeholderText:[{type:t.Input}],requiredErrorText:[{type:t.Input}],invalidErrorText:[{type:t.Input}],appearance:[{type:t.Input}],address:[{type:t.Input}],country:[{type:t.Input}],placeIdOnly:[{type:t.Input}],strictBounds:[{type:t.Input}],types:[{type:t.Input}],type:[{type:t.Input}],autoCompleteOptions:[{type:t.Input}],onChange:[{type:t.Output}],onAutocompleteSelected:[{type:t.Output}],onLocationSelected:[{type:t.Output}]},e}(),p=function(){function e(e,n,r){this.elemRef=e,this.mapsAPILoader=n,this._ngZone=r,this.autoCompleteOptions={},this.onChange=new t.EventEmitter,this.onAutocompleteSelected=new t.EventEmitter,this.onLocationSelected=new t.EventEmitter,this.onNewPlaceResult=new t.EventEmitter,this.addressValidator=new s,this.addressSearchControl=new o.FormControl({value:null},o.Validators.compose([o.Validators.required,this.addressValidator.validate()]))}return e.prototype.ngOnInit=function(){this.addressValidator.subscribe(this.onNewPlaceResult);var e={componentRestrictions:{country:this.country},placeIdOnly:this.placeIdOnly,strictBounds:this.strictBounds,types:this.types,type:this.type};this.autoCompleteOptions=Object.assign(this.autoCompleteOptions,e),this.initGoogleMapsAutocomplete()},e.prototype.initGoogleMapsAutocomplete=function(){var e=this;this.mapsAPILoader.load().then(function(){var t=new google.maps.places.Autocomplete(e.elemRef.nativeElement,e.autoCompleteOptions);t.addListener("place_changed",function(){e._ngZone.run(function(){var o=t.getPlace();o.place_id&&void 0!==o.geometry&&null!==o.geometry&&(e.address=o.formatted_address,e.onAutocompleteSelected.emit(o),e.onLocationSelected.emit({latitude:o.geometry.location.lat(),longitude:o.geometry.location.lng()}))})})}).catch(function(e){return console.log(e)})},e.decorators=[{type:t.Directive,args:[{selector:"[matGoogleMapsAutocomplete]",exportAs:"matGoogleMapsAutocomplete"}]}],e.ctorParameters=function(){return[{type:t.ElementRef},{type:n.MapsAPILoader},{type:t.NgZone}]},e.propDecorators={address:[{type:t.Input}],country:[{type:t.Input}],placeIdOnly:[{type:t.Input}],strictBounds:[{type:t.Input}],types:[{type:t.Input}],type:[{type:t.Input}],autoCompleteOptions:[{type:t.Input}],onChange:[{type:t.Output}],onAutocompleteSelected:[{type:t.Output}],onLocationSelected:[{type:t.Output}]},e}(),d=function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e.decorators=[{type:t.NgModule,args:[{imports:[r.CommonModule,o.FormsModule,o.ReactiveFormsModule,a.MatInputModule],exports:[l,p,s],declarations:[l,p,s]}]}],e}();e.MatGoogleMapsAutocompleteComponent=l,e.Appearance=i,e.MatValidateAddressDirective=s,e.MatGoogleMapsAutocompleteDirective=p,e.MatGoogleMapsAutocompleteModule=d,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=google-maps-autocomplete.umd.min.js.map
